/*
 * CacheItem.java
 * 
 * BrowserNG - A workbench for the browser of the new generation
 * Copyright (C) 2012 Ioannis Charalampidis
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 */
package gr.wavesoft.webng.webstreams;
import gr.wavesoft.webng.io.SystemConsole;
import gr.wavesoft.webng.io.WebNGIO;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author icharala
 */
public class CacheItem {
    
    private static final SystemConsole.Logger systemLogger = new SystemConsole.Logger(CacheItem.class, "CacheToken");
    public String key;
    public Long id;
    
    /**
     * When the SOFT TTL expires the resource must be re-validated by the server.
     * This timeout is usually defined by the response object.
     */
    private static final long DEFAULT_SOFT_TTL = 3600l; // 1 hour
    
    /**
     * When the HARD TTL expires, the resource is removed from the cache. 
     * The hard TTL is used when the server is unreachable but we still need to
     * view the resource. This TTL is usually constant and defined here.
     */
    private static final long DEFAULT_HARD_TTL = 7 * 24 * DEFAULT_SOFT_TTL; // 1 week
    
    /**
     * The entry is being cached
     */
    public static final int STATE_PENDING = 0;
    
    /**
     * The entry was successfully cached
     */
    public static final int STATE_CACHED = 1;
    
    /**
     * The date (milliseconds) of the last probe for the soft TTL
     */
    public Long dateProbed = 0l;
    
    /**
     * The date (milliseconds) of the last time the resource was updated
     * This is used for the hard TTL.
     */
    public Long dateUpdated = 0l;
    
    /**
     * The soft TTL value in seconds
     * (Defaults to DEFAULT_SOFT_TTL)
     */
    public Long softTTL;
    
    /**
     * The hard TTL Value in seconds
     * (Defaults to DEFAULT_HARD_TTL)
     */
    public Long hardTTL;
    
    /**
     * The state of the cached item
     * (See the STATE_ constants)
     */
    public int state;
    
    /**
     * The size of the resource in bytes
     */
    public Long size;
    
    /**
     * Arbitrary data the transport layer might need to store
     * Currently only string data are supported.
     */
    public String customData;

    /**
     * Fetch cache item or create new, using the given cache key
     * @param key The cache key, usually generated by the StreamRequest
     */
    public CacheItem(String key) {
        this.key = key;
        this.id = getID(key);
        if (this.id == null)
            this.id = allocate();
        if (this.id == null) {
            systemLogger.error("Unable to allocate new cache entry for key "+key);
            return;
        }
        load();
    }

    /**
     * Fetch cache item from the database using the given index
     * @param id The index of the cached item
     */
    public CacheItem(Long id) {
        this.id = id;
        load();
    }
    
    /**
     * Allocate new cache entry
     * @return Returns the entry ID
     */
    private Long allocate() {
        try {
            // Create new
            WebNGIO.dbUpdate("INSERT INTO cache_store (key, state, probed, updated, hardttl, softttl) VALUES(?,?,?,?,?,?)", 
                    key, STATE_PENDING, 0, 0, DEFAULT_HARD_TTL, DEFAULT_SOFT_TTL);

            // Query for the ID
            ResultSet res = WebNGIO.dbQuery("SELECT id FROM cache_store ORDER BY id DESC LIMIT 0,1");
            if (res == null) return null;
            if (!res.next()) {
                systemLogger.error("Unable to detect the new cache_store entry's ID!");
                return null;
            }

            // Fetch the id
            return res.getLong("id");
            
        } catch (SQLException ex) {
            systemLogger.except(ex);
            return null;
        }   
    }
    
    /**
     * Returns the ID of the given key
     * @param key The cache key
     * @return The entry ID
     */
    private Long getID(String key) {
        try {
            // Perform query
            ResultSet res = WebNGIO.dbQuery("SELECT id FROM cache_store WHERE key = ?", key);
            if (res == null) return null;
            if (!res.next()) return null;
            
            // Return the ID
            return res.getLong("id");
            
        } catch (SQLException ex) {
            systemLogger.except(ex);
            return null;
        }     
    }
    
    /**
     * Load the entry identified by the cache item's id
     */
    private void load() {
        try {
            // Perform query
            ResultSet res = WebNGIO.dbQuery("SELECT * FROM cache_store WHERE id = ?", id);
            if (res == null) return;
            if (!res.next()) return;
            
            // Fetch info from the DB
            dateProbed = res.getLong("probed");
            dateUpdated = res.getLong("updated");
            state = res.getInt("state");
            softTTL = res.getLong("softttl");
            hardTTL = res.getLong("hardttl");
            key = res.getString("key");
            customData = res.getString("custom");
            size = res.getLong("size");
            
        } catch (SQLException ex) {
            systemLogger.except(ex);
        }
    }
    
    /**
     * Save cached item information in the database
     */
    public void save() {
        if (this.id == null) return;
        WebNGIO.dbUpdate("UPDATE cache_store SET probed = ?, updated = ?, "
                + "state = ?, softttl = ?, hardttl = ?, key = ?, custom = ?, size = ? WHERE id = ?", 
                dateProbed, dateUpdated, state, softTTL, hardTTL, key, customData, size, id);
    }
    
    /**
     * Delete the cached item entry
     */
    public void delete() {
        if (this.id == null) return;
        WebNGIO.dbUpdate("DELETE FROM cache_store WHERE id = ?", id);
    }
    
    /**
     * Check if the given entry is expired

     * This function returns true if the hard TTL is expired.
     * 
     * @return Returns true if the entry is expired
     */
    public Boolean isExpired() {
        if (dateUpdated == 0l) return true;
        Long time = System.currentTimeMillis();
        return (dateUpdated+hardTTL*1000) < time;
    }
    
    /**
     * Check if the given entry is still warm

     * This function returns true if the soft TTL is no expired.
     * 
     * @return Returns true if the entry is warm
     */
    public Boolean isWarm() {
        if (dateProbed == 0l) return false;
        Long time = System.currentTimeMillis();
        return (dateProbed+softTTL*1000) >= time;
    }

    @Override
    public String toString() {
        return "[CacheItem key="+key+",softTTL="+softTTL+",hardTTL="+hardTTL+",state="+state+",size="+size+"]";
    }
    
}
